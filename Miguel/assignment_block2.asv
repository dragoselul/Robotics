%% Functions

function matrix = translationMatrix(x, y, z)
    % translationMatrix returns the homogeneous transformation matrix
    % for a translation along x, y, z axes.
    %
    % x = translation along X axis
    % y = translation along Y axis
    % z = translation along Z axis

    % homogeneous 4x4 translation matrix
    matrix = [1, 0, 0, x;
              0, 1, 0, y;
              0, 0, 1, z;
              0, 0, 0, 1];
end


function matrix = rotationX(x)
% rotationMatrixH  Homogeneous rotation matrices (4x4).
%
%   x = rotation about X axis (rad)


    matrix = [1, 0,       0,      0;
              0, cos(x), -sin(x), 0;
              0, sin(x),  cos(x), 0;
              0, 0,       0,       1];

end

function matrix = rotationY(y)
% rotationMatrixH  Homogeneous rotation matrices (4x4).
%
%   y = rotation about Y axis (rad)

    
    matrix = [ cos(y), 0, sin(y), 0;
                0,       1, 0,       0;
                -sin(y), 0, cos(y), 0;
                0,       0, 0,       1];

end

function matrix = rotationZ(z)
% rotationMatrixH  Homogeneous rotation matrices (4x4).
%   z = rotation about Z axis (rad)
    matrix = [cos(z), -sin(z), 0, 0;
              sin(z),  cos(z), 0, 0;
              0,        0,       1, 0;
              0,        0,       0, 1];

end


function point = extractXYZ(A)

    matrix.size = size(A);

    if sum(size(A) == [matrix.size(1) matrix.size(1)]) < 2
        
        error('Matrix is not square')

    end

    point = A(1:end-1, matrix.size(1));

end 


function vector = extractXYZvectors(A, vector_name)

    % where A is the H matrix

    matrix.size = size(A);

    if sum(size(A) == [matrix.size(1) matrix.size(1)]) < 2
        
        error('Matrix is not square')

    end

    if vector_name == 1 %x
        vector = A(1:end-1, 1);
    elseif vector_name == 2 %y
        vector = A(1:end-1, 2);
    elseif vector_name == 3 %z
        vector = A(1:end-1, 3);
    else
        error("Incorrect vector, give range from 1-3")
    end

end 


function transformation = DH(theta, dz, dx, alpha)
    
    transformation = rotationZ(theta) * translationMatrix(0, 0, dz) * translationMatrix(dx, 0, 0) * rotationX(alpha);

end

function angle = cosTheorem(a, b, c)

    % where a, b, c are the sides of the triangle
    syms x
    value_cos = solve(a^2 == b^2 + c^2 - 2*b*c*x, x);

    angle = acos(double(value_cos));

end 


function module = modulusVector(X)

    module = sqrt(X(1)^2 + X(2)^2 + X(3)^2);

end

function jacobian = Jvw(rotation_axis, end_effector, origin)

    % function returns Jv1 Jw1 nx1 vector for a column of the Jacobian in
    % terms of theta1 - theta4
    % ONLY VALID FOR ROTATIONAL JOINTS

    syms theta1 theta2 theta3 theta4

    Jv = skew(rotation_axis) * (end_effector - origin);
    Jw = rotation_axis;

    jacobian = [Jv' , Jw']';
    
end 


%% Problem 6
clear 
clc

% The trajectories at this problem simply approximates the joint angles,
% rates and accelerations as a function of time by computing a series of
% coefficients

% Take these from problem 2

% Variables

syms theta1 theta2 theta3 theta4

% Define full DH transforms

T01 = DH(theta1, 50, 0, sym(pi/2));
T12 = DH(theta2 + sym(pi/2), 0, 93, 0);
T23 = DH(theta3, 0, 93, 0);
T34 = DH(theta4, 0, 50, 0);
T03 = simplify(T01 * T12 * T23);
T04 = simplify(T01 * T12 * T23 * T34);



function vector = computeMatrixCoeff(X, t)

    % ONLY VALID FOR BUILDING COEFF MATRIX

    % where X is a vector (row)
    % functions works out its polinomial evaluation like:
    % [a, b, c] = at^2, bt, c
    % t is where the vector is evaluated

    % remove 0's at the end of the vector

    % add 0 counter
    counter = 0;
    while X(end) == 0
        X(end) = [];
        counter = counter + 1;
    end
    
    n = length(X);

    exponents = n-1:-1:0;

    vector = [];

    for i = 1:n
        
        vector(end+1) = t^exponents(i) * X(i);
        
    end 

    vector = [vector, zeros(1, counter)];

end

function matrix = coeffMatrix(n, tA, tB)

    % where n is the number of columns of the matrix
    % matrix ALWAYS has 6 rows (qa, qdot_a, qddot_a, qb, qdot_b, qddot_b)
    % tA is the initial boundary condition at t0 
    % tB is the final boundary condition at tfinal

    % this considers the coeffs to be 1 for the angle approx polynomial and
    % cascaded down

    if n == 8

        row15 = [linspace(1, 1, n)];
        row26 = [polyder(row15), 0];
        row37 = [polyder(polyder(row15)), 0,0];
        row48 = [polyder(polyder(polyder(row15))), 0,0,0];
    
        row1 = computeMatrixCoeff(row15, tA);
        row2 = computeMatrixCoeff(row26, tA); 
        row3 = computeMatrixCoeff(row37, tA);
        row4 = computeMatrixCoeff(row48, tA);
        row5 = computeMatrixCoeff(row15, tB);
        row6 = computeMatrixCoeff(row26, tB);
        row7 = computeMatrixCoeff(row37, tB);
        row8 = computeMatrixCoeff(row48, tB);

        matrix = [row1; row2; row3; row4; row5; row6; row7; row8];

    elseif n < 8
        row14 = [linspace(1, 1, n)];
        row25 = [polyder(row14), 0];
        row36 = [polyder(polyder(row14)), 0,0];
    
        row1 = computeMatrixCoeff(row14, tA);
        row2 = computeMatrixCoeff(row25, tA); 
        row3 = computeMatrixCoeff(row36, tA);
        row4 = computeMatrixCoeff(row14, tB);
        row5 = computeMatrixCoeff(row25, tB);
        row6 = computeMatrixCoeff(row36, tB);
    
        matrix = [row1; row2; row3; row4; row5; row6];
     end

    

end


% Test

% coeffMatrix(6, 0, 2)



function coeffs = computeCoefficients(n, tA, tB, qa, qdot_a, qddot_a, qb, qdot_b, qddot_b)

    % solutions in 4xn format

    % q = [theta1, theta2, theta3, theta4]'

    % insert on more DOF for jerk = 0 so matrix can go up to 8 unknowns to
    % solve for 8x8 matrix

    if n == 8
        solution = [qa', qdot_a, qddot_a, [0, 0, 0, 0]', qb', qdot_b, qddot_b, [0, 0, 0, 0]'];
    elseif n < 8
        solution = [qa', qdot_a, qddot_a, qb', qdot_b, qddot_b];
    end

    % Compute matrix for this solution space between tA and tB

    matrix = coeffMatrix(n, tA, tB);

    q1_coeffs = matrix \ solution(1, :)';
    q2_coeffs = matrix \ solution(2, :)';
    q3_coeffs = matrix \ solution(3, :)';
    q4_coeffs = matrix \ solution(4, :)';

    coeffs = [q1_coeffs'; q2_coeffs'; q3_coeffs'; q4_coeffs'];

end

% ---- LOAD THE POSES, JACOBIANS AND POSITIONS AT 0 90 180 270º ---- 

load("pose_indexes.mat")
load("poses.mat")
load('jacobian_psi_0.mat')
load('jacobian_psi_90.mat')
load('jacobian_psi_180.mat')
load('jacobian_psi_270.mat')

% These are always 0

qddot_a = [0; 0; 0; 0];
qddot_b = [0; 0; 0; 0];

% Compute the circle points

circle_center = [150; 0; 120];
R = 32;
angles = 0:2*pi/36:pi*2;
circle_points = circleDrawer(circle_center, R, angles);

% BEST RESULTS FOR EITHER 6 OR 8

number_coefficients = 6; 

% --- FIRST QUADRANT (t = 0-2s) -----

qa = poses(pose_index(1), :);
qb = poses(pose_index(2), :);
va = [0; 0; 0]; % from exercise conditions
vb = [0; -27; 0]; % from exercise conditions
tA = 0; % from exercise conditions
tB = 2; % from exercise conditions

pa = circle_points(:, pose_index(1)); % point at position A
pb = circle_points(:, pose_index(2)); % point at position B

% Now calc the angular rates qdot_a and qdot_b

JvA = jacobian_psi_0(1:3, :);
JvB = jacobian_psi_90(1:3, :);

% Overactuated arm pseudoinverse

pseudoinverse_J_A = JvA'*inv(JvA*JvA');
pseudoinverse_J_B = JvB'*inv(JvB*JvB');

qdot_a = double(pseudoinverse_J_A*va);
qdot_b = double(pseudoinverse_J_B*vb); 

% Theta1 to Theta4 coefficients

Acoeffs = computeCoefficients(number_coefficients, tA, tB, qa, qdot_a, qddot_a, qb, qdot_b, qddot_b);

% --- SECOND QUADRANT (t = 2-4s) -----

indexA = pose_index(2);
indexB = pose_index(3);

qa = poses(indexA, :); % pose at point psi 90º
qb = poses(indexB, :); % pose at point psi 180º
va = [0; -27; 0]; % from exercise conditions
vb = [0; 0; -27]; % from exercise conditions
tA = 2; % from exercise conditions
tB = 4; % from exercise conditions

pa = circle_points(:, indexA); % point at position A
pb = circle_points(:, indexB); % point at position B

% Now calc the angular rates qdot_a and qdot_b

JvA = jacobian_psi_90(1:3, :);
JvB = jacobian_psi_180(1:3, :);

% Overactuated arm pseudoinverse

pseudoinverse_J_A = JvA'*inv(JvA*JvA');
pseudoinverse_J_B = JvB'*inv(JvB*JvB');

qdot_a = double(pseudoinverse_J_A*va);
qdot_b = double(pseudoinverse_J_B*vb); 

% Theta1 to Theta4 coefficients

Bcoeffs = computeCoefficients(number_coefficients, tA, tB, qa, qdot_a, qddot_a, qb, qdot_b, qddot_b);

% --- THIRD QUADRANT (t = 4-6s) -----

indexA = pose_index(3);
indexB = pose_index(4);

qa = poses(indexA, :); % pose at point psi 90º
qb = poses(indexB, :); % pose at point psi 180º
va = [0; 0; -27]; % from exercise conditions
vb = [0; 27; 0]; % from exercise conditions
tA = 4; % from exercise conditions
tB = 6; % from exercise conditions

pa = circle_points(:, indexA); % point at position A
pb = circle_points(:, indexB); % point at position B

% Now calc the angular rates qdot_a and qdot_b

JvA = jacobian_psi_180(1:3, :);
JvB = jacobian_psi_270(1:3, :);

% Overactuated arm pseudoinverse

pseudoinverse_J_A = JvA'*inv(JvA*JvA');
pseudoinverse_J_B = JvB'*inv(JvB*JvB');

qdot_a = double(pseudoinverse_J_A*va);
qdot_b = double(pseudoinverse_J_B*vb); 

% Theta1 to Theta4 coefficients

Ccoeffs = computeCoefficients(number_coefficients, tA, tB, qa, qdot_a, qddot_a, qb, qdot_b, qddot_b);


% --- FOURTH QUADRANT (t = 6-8s) -----

indexA = pose_index(4);
indexB = pose_index(1);

qa = poses(indexA, :); % pose at point psi 90º
qb = poses(indexB, :); % pose at point psi 180º
va = [0; 27; 0]; % from exercise conditions
vb = [0; 0; 0]; % from exercise conditions
tA = 6; % from exercise conditions
tB = 8; % from exercise conditions

pa = circle_points(:, indexA); % point at position A
pb = circle_points(:, indexB); % point at position B

% Now calc the angular rates qdot_a and qdot_b

JvA = jacobian_psi_270(1:3, :);
JvB = jacobian_psi_0(1:3, :);

% Overactuated arm pseudoinverse

pseudoinverse_J_A = JvA'*inv(JvA*JvA');
pseudoinverse_J_B = JvB'*inv(JvB*JvB');

qdot_a = double(pseudoinverse_J_A*va);
qdot_b = double(pseudoinverse_J_B*vb); 

% Theta1 to Theta4 coefficients

Dcoeffs = computeCoefficients(number_coefficients, tA, tB, qa, qdot_a, qddot_a, qb, qdot_b, qddot_b);


%% Problem 7

% RUN EXERCISE 6 BEFORE DOING 7!!!!!! DO NOT CLEAN THE OUTPUT

% Essentially a time continuous function that takes my theta1(t) to theta4(t) and gives me a robot path. This can be achieved running the 
% homogenous transformation matrix discretly from frame 0 until frame 4

% First, extract the function fx(theta1(t), theta2(t), theta3(t),
% theta4(t)), fy and fz respectively for the point. This is essentially a
% function of a function 

point_functionXYZ = extractXYZ(T04); % point [x, y, z]' vector

% Create a function that can loop through the point function between 2 time
% intervals and a defined set of coefficients

global number_points

number_points = 40;

function points = computePlot(tA, tB, coeff, point_functionXYZ)

    syms theta1 theta2 theta3 theta4

    global number_points

    % tA - initial time
    % tB - final time 
    % coeff - coefficients matrix either A, B, C or D (gives coeffs to all the theta1(t) - theta4(t) expressions)

    % Compute the numerical value of the vector components evaluated at a
    % time t and then sum the elements to get the vector, numerical value

    % Use a loop for that, then add all of them into a list of points [3, n]

    % Define the number of time intervals t (number of points) 

    points = zeros(3, number_points);

    index = 1;

    for t = linspace(tA, tB, number_points) % 40 points per interval
      
        theta1_t = sum(computeNumVect(coeff(1, :), t));
        theta2_t = sum(computeNumVect(coeff(2, :), t));
        theta3_t = sum(computeNumVect(coeff(3, :), t));
        theta4_t = sum(computeNumVect(coeff(4, :), t));

        % With the fed xyz function, subs the theta values by the computed
        % thetas at that time interval for the X, Y and Z coordinates

        points(:, index) = subs(point_functionXYZ, [theta1, theta2, theta3, theta4], [theta1_t, theta2_t, theta3_t, theta4_t]);

        index = index + 1;
             
    end

end 

% Compute the trajectories for the circle 

circle_trajectory = zeros(3, number_points * 4);

coeffs_all = {Acoeffs, Bcoeffs, Ccoeffs, Dcoeffs};

indexer = [0];

% where i defines the 4 quadrants of the circle 
time_interval = [0, 2];

for i = 1:4

    % Keep track of the number of points to add to the list in batches of
    % number of points 

    indexer(end+1) = i * number_points; 

    circle_trajectory(:, indexer(i) + 1 : indexer(i + 1)) = computePlot(time_interval(1), time_interval(2), coeffs_all{i}, point_functionXYZ);

    time_interval = time_interval + 2;
end 

% Compute the circle points

circle_center = [150; 0; 120];
R = 32;
angles = 0:2*pi/36:pi*2;
circle_points = circleDrawer(circle_center, R, angles);
circle_path = circle_points';


% Plot comparison
figure;
plot3(circle_trajectory(1, :), circle_trajectory(2, :), circle_trajectory(3, :), 'LineWidth', 1.8);
hold on;
plot3(circle_path(:,1), circle_path(:,2), circle_path(:,3), 'r--', 'LineWidth', 2);
xlabel('X'); ylabel('Y'); zlabel('Z');
legend('Interpolated Path', 'Ideal Circular Path');
title('End-Effector Trajectory vs. Ideal Circle');
grid on; axis equal;

%% Problem 8

% RUN EXERCISE 6 BEFORE RUNNING THIS ONE!!!

% Compute the circle points 36 points in total

circle_center = [150; 0; 120];
R = 32;
angles = 0:2*pi/36:pi*2;
circle_points = circleDrawer(circle_center, R, angles);
circle_path = circle_points';

% Load the jacobian for the matrix, variable called jacobian_sym (in terms of theta1-theta4)
% Also load the poses to feed to the jacobian for every instant around the
% ideal circle trajectory. The calculated trajectory (thetas) calculated in
% ex 7 also have to be fed into the jacobian 

load('jacobian_sym_circle')
load('poses.mat')
coeffs_all = {Acoeffs, Bcoeffs, Ccoeffs, Dcoeffs};
pose_index = [1, 36/4 * 1 + 1, 36/4 * 2 + 1, 36/4 * 3 + 1]; % splits circle into 4 quadrants

% Compute the jacobian and store its matrix cond in a list

jacobian_ideal_cond = zeros(length(angles), 1);
jacobian_trajectory_cond = zeros(length(angles), 1);

trajectory_poses = zeros(length(angles), 4);

function t_fit = computeTime(n_samples, t_interval)

    % function takes a time interval and fits x time samples into the
    % interval for use within the computed traj jacobian
    % where t_interval is a vector
    
    t_fit = linspace(t_interval(1), t_interval(2), n_samples);

end

counterA = 1;
counterB = 1;
counterC = 1;
counterD = 1;

for i = 1:length(angles)

    jacobian_ideal_cond(i) = cond(numericJacobian(jacobian_sym, poses(i, :)));

    % Compute the thetas for the 4 quadrants given the trajectory
    % interpolation (depends on quadrant)
    % t has to be normalized between the different segments to be plugged
    % into the function 

    if i <= pose_index(2)
        t = computeTime(10, [0, 2]);
        coeff = coeffs_all{1};
        theta1_t = sum(computeNumVect(coeff(1, :), t(counterA)));
        theta2_t = sum(computeNumVect(coeff(2, :), t(counterA)));
        theta3_t = sum(computeNumVect(coeff(3, :), t(counterA)));
        theta4_t = sum(computeNumVect(coeff(4, :), t(counterA)));
        counterA = counterA + 1;
    elseif i <= pose_index(3)
        t = computeTime(9, [2, 4]);
        coeff = coeffs_all{2};
        theta1_t = sum(computeNumVect(coeff(1, :), t(counterB)));
        theta2_t = sum(computeNumVect(coeff(2, :), t(counterB)));
        theta3_t = sum(computeNumVect(coeff(3, :), t(counterB)));
        theta4_t = sum(computeNumVect(coeff(4, :), t(counterB)));
        counterB = counterB + 1;
    elseif i <= pose_index(4)
        t = computeTime(9, [4, 6]);
        coeff = coeffs_all{3};
        theta1_t = sum(computeNumVect(coeff(1, :), t(counterC)));
        theta2_t = sum(computeNumVect(coeff(2, :), t(counterC)));
        theta3_t = sum(computeNumVect(coeff(3, :), t(counterC)));
        theta4_t = sum(computeNumVect(coeff(4, :), t(counterC)));
        counterC = counterC + 1;
    else
        t = computeTime(9, [6, 8]);
        coeff = coeffs_all{4};
        theta1_t = sum(computeNumVect(coeff(1, :), t(counterD)));
        theta2_t = sum(computeNumVect(coeff(2, :), t(counterD)));
        theta3_t = sum(computeNumVect(coeff(3, :), t(counterD)));
        theta4_t = sum(computeNumVect(coeff(4, :), t(counterD)));
        counterD = counterD + 1;
    end

    trajectory_poses(i, :) = [theta1_t, theta2_t, theta3_t, theta4_t];

    jacobian_trajectory_cond(i) = cond(numericJacobian(jacobian_sym, trajectory_poses(i, :)));

end

% FIGURE 1 FOR THE COND OF THE EXERCISE

figure;
plot(angles, jacobian_ideal_cond, 'b-', 'LineWidth', 1.8); hold on;
plot(angles, jacobian_trajectory_cond, 'r--', 'LineWidth', 1.8);
grid on; box on;

xlabel('Circle sweep angle \psi [rad]');
ylabel('cond(J)');
title('Jacobian Condition Number Along Circular Trajectory');

legend({'Ideal trajectory (IK-based)', ...
        'Interpolated trajectory (polynomial)'}, ...
        'Location', 'best');

xlim([min(angles) max(angles)]);
set(gca, 'FontSize', 11, 'LineWidth', 1);

% FIGURE 2 - VISUAL REP OF THE ACTUAL THETAS AND THE INTERPOLATED ONES

figure;

titles = {'\theta_1(t)', '\theta_2(t)', '\theta_3(t)', '\theta_4(t)'};

for k = 1:4
    subplot(2,2,k)
    plot(angles, poses(:,k), 'LineWidth', 1.8); hold on
    plot(angles, trajectory_poses(:,k), '--', 'LineWidth', 1.8);
    grid on
    xlabel('Angle along circle [rad]');
    ylabel(['\theta_' num2str(k) ' [rad]']);
    title(['Comparison of ' titles{k}]);
    legend('Ideal (IK)', 'Interpolated (poly)');
end

sgtitle('Comparison of Joint Angles: Ideal vs Interpolated Trajectory');

% Quick explanation on the singularity side. The closes the trajectory is
% to the robot's base the smaller the condition (further away from
% singularity). We can see that for a robot arm that cannot reach space
% (say the point to reach is much farther than the robot arms lenghts) the
% jacobian will hit a singularity, meaning it cannot reach that pose and
% therefore its rank reduce and cond -> inf (det (0) condition). We see
% that the upper point of the circle's trajectory at pi/2 radians the cond
% hits its highest, meaning its the closest point to singularity. However
% the base of the circle trajectory at 3pi/2 rads is closest and most
% achievable to the robot config, thus furthest from singularity. 

%% Problem 9

% The force applied at the stylus tip is 1Nm = 1000Nmm in our case. The
% moment seen at joint 4 is given by the force acting downwards in z always
% so -Fz and the M applied at a distance 50mm from joint 4. M is given by r
% x F (cross product) 

% Need the jacobian for torque calcs = jacobian_sym

load('jacobian_sym_circle')

jacobian_T = jacobian_sym'; % transposed Jacobian

% So put together the F and J^T vector and matrix to compute the torque

function torques = computeTorques(fx, fy, fz, poses, jacobian_T)

    % poses = theta1 - theta4 at a specific point of the trajectory
    % only valid for stylus tip where forces are applied at a disctance to
    % the last joint, inducing bending moments as well

    % in this case the r vector perpendicular to axis of rotation is the
    % unit x vector multiplied by the distance to the force 50

    % Import the DH transform to extract the X vector (distance to force) to
    % get momentum
        
    % Define full DH transforms
    
    T01 = DH(poses(1), 50, 0, sym(pi/2));
    T12 = DH(poses(2) + sym(pi/2), 0, 93, 0);
    T23 = DH(poses(3), 0, 93, 0);
    T34 = DH(poses(4), 0, 50, 0);
    T04 = T01 * T12 * T23 * T34;

    x_axisT04 = T04(:, 1);

    M = skew(x_axisT04.*50) * [fx; fy; fz];

    % jacobian_T = transposed symbolic jacobian
    % force = force and BM acting in joint 4 depending on point of the
    % circle trajectory

    syms theta1 theta2 theta3 theta4

    jacobian_numeric = double(subs(jacobian_T, [theta1, theta2, theta3, theta4], [poses(1), poses(2), poses(3), poses(4)]));

    force = [fx, fy, fz, M']';

    torques = jacobian_numeric * force;

end


% Now compute the torques at all 4 joints for each point of the trajectory,
% save them into a list and then plot them

% Compute the circle points 37 points in total

circle_center = [150; 0; 120];
R = 32;
angles = 0:2*pi/36:pi*2;
circle_points = circleDrawer(circle_center, R, angles);
circle_path = circle_points';
torques = zeros(length(angles), 4);

% Inputs from problem
load('poses.mat')
fx = 0;
fy = 0;
fz = 1; % N

% compute torques completes the force vector with the moments and
% calculates torque directly

for i = 1:length(angles)

    torques(i, :) = computeTorques(fx, fy, fz, poses(i, :), jacobian_T);

end

figure;
plot(angles, torques(:,1), 'LineWidth', 1.8); hold on;
plot(angles, torques(:,2), 'LineWidth', 1.8);
plot(angles, torques(:,3), 'LineWidth', 1.8);
plot(angles, torques(:,4), 'LineWidth', 1.8);

grid on; box on;

xlabel('Circle sweep angle \psi [rad]');
ylabel('Joint torque \tau_i [N·mm]');
title('Joint Torques Required for Circular End-Effector Trajectory');
legend({'\tau_1','\tau_2','\tau_3','\tau_4'}, 'Location','best');

xlim([min(angles) max(angles)]);
set(gca, 'FontSize', 11, 'LineWidth', 1);


%% Problem 10

% MODEL ALSO TRIED TO BE SOLVED IN SIMULINK! NUMERICAL LAGRANGIAN

% CHANGE OF TACTIC, SYMBOLIC CALCULATION

% The CMs of the links are expressed relative to the frame locations of the
% different links (links 2/3 having the same CM)

% So firstly, work out the moment of inertia Io common to all links, using
% link1, its longitudinal dimension 50mm (b) and the mass of 60g of the arm

% The dimension relationship goes as follows b = 50mm and a is 0.1*b c will
% be a free parameter to optimise the sum of squared errors (system is
% overdimensioned, there are more equations than unknowns) Several vectors
% satisfy the conditions of the problem Ax = b

m1 = 0.060; % in kg
b = 0.050; 
a = 0.1 * b;
c = 0.1 * b; 

k = 1/12 * m1;

% I0 == Ixx 

I0 = k * (b^2 + c^2)

%% 

% Where D are the inertia matrices;

D1 = [1 0 0; 0 0.4 0; 0 0 0.9] .* I0;
D2 = [0.45 0 0; 0 1.4 0; 0 0 1.2] .* I0;
D3 = D2;
D4 = eye(3) .* 0.5 * I0;

% The langrangian is done in terms of time, therefore the poses and the
% pose derivatives calculated on exercise 6

% KINETIC ENERGY CALCULATIONS

% For these, we need:
% 1. Jacobian evaluated at COM for each link - use modified DH
% 2. Derivative in terms of time of the joint rates - theta1_dot(t),
% theta2_dot(t) ... extracted from the coeffs A B C and D

% The new jacobian matrix for each of the COM must be calculated


% Lets calculate the kinetic energy with a function





function L = computeLagrangian(K, P)

    % where K = kinetic energy
    % where P = potential energy

    L = K - P;

end 

